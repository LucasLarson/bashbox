#!/usr/bin/env bash
bashbox_arch() {
	#!/usr/bin/env bash
	#
	# arch in pure bash.
	
	echo "$HOSTTYPE"
}
bashbox_basename() {
	#!/usr/bin/env bash
	#
	# basename in pure bash.
	
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
}
bashbox_cat() {
	#!/usr/bin/env bash
	#
	# cat in pure bash.
	
	if [[ "$#" == 0 ]]; then
	    while read -rn1; do echo "$REPLY"; done
	else
	    for file in "$@"; do
	        if [[ -f $file ]]; then
	            printf '%s\n' "$(<"$file")"
	        else
	            printf '%s\n' "cat: $file: No such file or directory" >&2
	        fi
	    done
	fi
}
bashbox_chr() {
	chr() {
	  [ "$1" -lt 256 ] || return 1
	  printf "\\$(printf '%03o' "$1")"
	}
	
	chr "$@"
}
bashbox_clear() {
	#!/usr/bin/env bas
	printf "\033c"
	#found this randomly and it seems to "work"
}
bashbox_cp() {
	#!/bin/sh
	if [ -z $1 ]; then
	  echo "cp: missing file name"
	  exit
	fi
	if [ -z $2 ]; then
	  echo "cp: missing target file name"
	  exit
	fi
	if [ ! -f $1 ]; then
	  echo "cp: file not found"
	  exit
	fi
	printf '%s\n' "$(<"$1")" > $2
	#cp in pure sh
	#test
}
bashbox_curl() {
	#!/usr/bin/env bash
	#
	# Download a file in pure bash.
	
	download() {
	    IFS=/ read -r _ _ host query <<< "$1"
	
	    # Send the HTTP request.
	    exec 3<"/dev/tcp/${host}/80"; {
	        printf '%s\r\n%s\r\n\r\n' \
	               "GET /${query} HTTP/1.0" \
	               "Host: $host"
	    } >&3
	
	    # Strip the HTTP headers.
	    while IFS= read -r line; do
	        [[ "$line" == $'\r' ]] && break
	    done <&3
	
	    # Output the file.
	    nul='\0'
	    while IFS= read -d '' -r line || { nul=""; [[ -n "$line" ]]; }; do
	        printf "%s%b" "$line" "$nul"
	    done <&3
	
	    exec 3>&-
	}
	
	if [ "$1" = "-o" ]; then
		download "$3" > "$2"
	else
		download "$1"
	fi
}
bashbox_date() {
	#!/usr/bin/env bash
	#
	# date in pure bash.
	
	date_format="$1"
	
	[[ ${date_format:0:1} == + ]] &&
	    date_format="${date_format/+}"
	
	printf "%($date_format)T\\n"
}
bashbox_dirname() {
	#!/usr/bin/env bash
	#
	# dirname in pure bash.
	
	for file in "$@"; do
	    printf '%s\n' "${file%/*}/"
	done
}
bashbox_echo() {
	#!/usr/bin/env bash
	#
	# echo in pure bash.
	
	echo "$@"
}
bashbox_env() {
	#!/usr/bin/env bash
	#
	# env in pure bash.
	
	mapfile -t envars < <(compgen -v)
	
	for var in "${envars[@]}"; do
	    printf '%s=%s\n' "$var" "${!var}"
	done
}
bashbox_exec() {
	#!/usr/bin/env bash
	shift
	$@
	exit
}
bashbox_expand() {
	#!/usr/bin/env bash
	#
	# expand in pure bash.
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "expand: $1: No such file or directory." >&2
	    exit 1
	}
	
	file="$(< "$1")"
	printf '%s\n' "${file//$'\t'/'        '}"
}
bashbox_expr() {
	#!/usr/bin/env bash
	#
	# expr in pure bash.
	
	printf '%s\n' "$(($@))"
}
bashbox_false() {
	#!/usr/bin/env bash
	#
	# false in pure bash.
	
	exit 1
}
bashbox_hd() {
	#!/usr/bin/env bash
	hd() {
	  if (($#)); then
	    hd <"$1"
	    return
	  fi
	  local IFS='' # disables interpretation of \t, \n and space
	  local LANG=C # allows characters > 0x7F
	  local bytes=0 char chars=''
	  declare -i bytes
	  printf '%08x  ' 0
	  while read -s -d '' -r -n 1 char; do  # -d '' allows newlines, -r allows \
	    printf '%02x ' "'$char" # see https://pubs.opengroup.org/onlinepubs/009695399/utilities/printf.html
	    [[ "$char" =~ [[:print:]] ]] || char='.' # display non-printables as a dot
	    chars+=$char
	    ((++bytes % 8)) && continue
	    printf ' '
	    ((bytes % 16)) && continue
	    printf '|%s|\n%08x  ' "$chars" "$bytes"
	    chars=''
	  done
	  if [[ "$chars" ]]; then
	    len=${#chars}
	    ((len > 7 && len--, len += (16 - (bytes % 16)) * 3 + 4))
	    printf "%${len}s\n%08x  " "|$chars|" "$bytes"
	  fi
	  printf '\n'
	}
	
	hd "$@"
}
bashbox_head() {
	#!/usr/bin/env bash
	#
	# head in pure bash.
	
	while getopts ":n:" opt; do
	    case $opt in
	        n) max_lines="$OPTARG" ;;
	
	        :)
	            printf '%s\n' "option -$OPTARG requires an argument." >&2
	            exit 1
	        ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	
	    shift "$((OPTIND - 1))"
	done
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "head: ${1:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile -n "${max_lines:-10}" file_data < "$1"
	printf '%s' "${file_data[@]}"
}
bashbox_hostname() {
	#!/usr/bin/env bash
	#
	# hostname in pure bash.
	
	: '\h'
	printf '%s\n' "${_@P}"
}
bashbox_locale() {
	#!/usr/bin/env bash
	#
	# locale in pure bash.
	
	locale_vars=(
	    LANG
	    LC_CTYPE
	    LC_NUMERIC
	    LC_TIME
	    LC_COLLATE
	    LC_MONETARY
	    LC_MESSAGES
	    LC_PAPER
	    LC_NAME
	    LC_ADDRESS
	    LC_TELEPHONE
	    LC_MEASUREMENT
	    LC_IDENTIFICATION
	)
	
	
	for var in "${locale_vars[@]}"; do
	    printf '%s=\"%s\"\n' "$var" "${!var:-$LANG}"
	done
	printf '%s=%s\n' "LC_ALL" "$LC_ALL"
}
bashbox_logname() {
	#!/usr/bin/env bash
	#
	# logname in pure bash.
	
	: '\u'
	printf '%s\n' "${_@P}"
}
bashbox_ls() {
	#!/usr/bin/bash
	#found this randomly and it kinda works
	printf '%s\n' *
}
bashbox_ord() {
	ord() {
	  LC_CTYPE=C printf '%d' "'$1"
	}
	ord "$@"
}
bashbox_printenv() {
	#!/usr/bin/env bash
	#
	# printenv in pure bash.
	
	[[ $1 ]] && {
	    printf '%s\n' "${!1}"
	    exit 0
	}
	
	mapfile -t envars < <(compgen -v)
	
	for var in "${envars[@]}"; do
	    printf '%s=%s\n' "$var" "${!var}"
	done
}
bashbox_printf() {
	#!/usr/bin/env bash
	#
	# printf in pure bash.
	
	printf "$@"
}
bashbox_pwd() {
	#!/usr/bin/env bash
	#
	# pwd in pure bash.
	
	printf '%s\n' "$PWD"
}
bashbox_realpath() {
	#!/usr/bin/env bash
	#
	# realpath in pure bash.
	
	file="${1%/}"
	parent_dir="${file%/*}"
	
	[[ -f ${PWD}/${file##*/} ]] && {
	    printf '%s\n' "${PWD}/${file##*/}"
	    exit 0
	}
	
	cd "$parent_dir" &>/dev/null || exit 1 &&
	    printf '%s\n' "${PWD}/${file##*/}"
}
bashbox_seq() {
	#!/usr/bin/env bash
	#
	# seq in pure bash.
	
	[[ -z $1 ]] && {
	    printf '%s\n' "seq: error: missing arguments." >&2
	    exit 1
	}
	
	[[ $2 ]] &&
	    first="$1"
	
	[[ $3 ]] &&
	    increment="$2"
	
	last="${*: -1}"
	
	for ((i=${first:=1};i<=last;i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
}
bashbox_sh() {
	#!/usr/bin/env bash
	bash --posix $@
}
bashbox_sleep() {
	#!/usr/bin/env bash
	if [ -z $1 ]; then
	  echo "sleep: syntax error"
	  exit
	fi
	read -d "" -rt $1
}
bashbox_tac() {
	#!/usr/bin/env bash
	for file in "$@"
	do
		i=0 
		
		while read line[$i] ; do
		    i=$(($i+1))
		done < $file
		
		
		for (( i=${#line[@]}-1 ; i>=0 ; i-- )) ; do
		    echo ${line[$i]}
		done
	done
}
bashbox_tail() {
	#!/usr/bin/env bash
	#
	# tail in pure bash.
	
	while getopts ":n:" opt; do
	    case $opt in
	        n) max_lines="$OPTARG" ;;
	
	        :)
	            printf '%s\n' "option -$OPTARG requires an argument." >&2
	            exit 1
	        ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	
	    shift "$((OPTIND - 1))"
	done
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "tail: ${1:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile -tn 0 file_data < "$1"
	
	[[ ${max_lines:=0} -gt "${#file_data[@]}" ]] &&
	    max_lines="${#file_data[@]}"
	
	printf '%s\n' "${file_data[@]: -$max_lines}"
}
bashbox_time() {
	$@
	echo "$SECONDS"
}
bashbox_touch() {
	#!/usr/bin/env bash
	#touch in pure bash
	if [ ! -f $1 ]; then
	 >$1
	fi
}
bashbox_tput() {
	#!/usr/bin/env bash
	shopt -s checkwinsize; (:;:)
	printhelp() {
	 echo "Usage: tput [command]
	colors:
	 16 colors:
	  native:
	   set - set color and property
	   set 0 0 - reset terminal
	  tput mode:
	   setaf - set foreground color
	   setab - set background color
	   sgr0 - reset terminal
	  256 colors:
	  esetf - set foreground color 
	  esetb - set backgroud color
	 24-bit colors:
	  rgb format:
	   rsetf - set foreground color
	   rsetb - set background color
	  hex format:
	   hsetf - set foreground color
	   hsetb - set background color
	cursor:
	 moving:
	  cup - moves cursor to given position
	etc:
	 patch - replaces tput in script with cput (does not always work)
	info:
	 cols - width of terminal
	 lines - height of terminal
	 pos - position of cursor
	 "
	}
	##colors
	get_cursor_pos() {
	    # Usage: get_cursor_pos
	    IFS='[;' read -p $'\e[6n' -d R -rs _ y x _
	    printf '%s\n' "$y $x"
	}
	modeput() {
	 printf "\033[$1;$2m"
	}
	rgbputf() {
	 printf "\033[38;2;$1;$2;$3m"
	}
	rgbputb() {
	 printf "\033[48;2;$1;$2;$3m"
	}
	if [ -z $1 ]; then
	 printhelp
	elif [ $1 = rsetf ]; then
	 printf "\033[38;2;$2;$3;$4m"
	elif [ $1 = rsetb ]; then
	 printf "\033[48;2;$2;$3;$4m"
	elif [ $1 = esetf ]; then
	 printf "\033[38;5;$2m"
	elif [ $1 = esetb ]; then
	 printf "\033[48;5;$2m"
	elif [ $1 = set ]; then
	 modeput $2 $3
	elif [ $1 = setaf ]; then
	 if [ $2 = 0 ]; then
	  modeput 0 30
	 elif [ $2 = 1 ]; then
	  modeput 0 31
	 elif [ $2 = 2 ]; then
	  modeput 0 32
	 elif [ $2 = 3 ]; then
	  modeput 0 33
	 elif [ $2 = 4 ]; then
	  modeput 0 34
	 elif [ $2 = 5 ]; then
	  modeput 0 35
	 elif [ $2 = 6 ]; then
	  modeput 0 36
	 elif [ $2 = 7 ]; then
	  modeput 0 37
	 elif [ $2 = 8 ]; then
	  modeput 0 90
	 elif [ $2 = 9 ]; then
	  modeput 0 91
	 elif [ $2 = 10 ]; then
	  modeput 0 92
	 elif [ $2 = 11 ]; then
	  modeput 0 93
	 elif [ $2 = 12 ]; then
	  modeput 0 94
	 elif [ $2 = 13 ]; then
	  modeput 0 95
	 elif [ $2 = 14 ]; then
	  modeput 0 96
	 elif [ $2 = 15 ]; then
	  modeput 0 97
	 elif [ $2 = 16 ]; then
	  modeput 0 98
	 else
	  modeput 0 31;echo cput: tput-mode: unknown color; modeput 0 0
	 fi
	elif [ $1 = setab ]; then
	 if [ $2 = 0 ]; then
	  modeput 0 40
	 elif [ $2 = 1 ]; then
	  modeput 0 41
	 elif [ $2 = 2 ]; then
	  modeput 0 42
	 elif [ $2 = 3 ]; then
	  modeput 0 43
	 elif [ $2 = 4 ]; then
	  modeput 0 44
	 elif [ $2 = 5 ]; then
	  modeput 0 45
	 elif [ $2 = 6 ]; then
	  modeput 0 46
	 elif [ $2 = 7 ]; then
	  modeput 0 47
	 elif [ $2 = 8 ]; then
	  modeput 0 100
	 elif [ $2 = 9 ]; then
	  modeput 0 101
	 elif [ $2 = 10 ]; then
	  modeput 0 102
	 elif [ $2 = 11 ]; then
	  modeput 0 103
	 elif [ $2 = 12 ]; then
	  modeput 0 104
	 elif [ $2 = 13 ]; then
	  modeput 0 105
	 elif [ $2 = 14 ]; then
	  modeput 0 106
	 elif [ $2 = 15 ]; then
	  modeput 0 107
	 elif [ $2 = 16 ]; then
	  modeput 0 108
	 else
	  modeput 0 41;echo cput: tput-mode: unknown color; modeput 0 0
	 fi
	elif [ $1 = sgr0 ]; then
	 modeput 0 0
	elif [ $1 = patch ]; then
	 sed -i 's/tput/cput/g' $2
	elif [ $1 = cup ]; then
	 printf "\033[$2;$3H"
	elif [ $1 = hsetf ]; then
	 r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	 g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	 b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	 rgbputf $r $g $b
	elif [ $1 = hsetb ]; then
	 r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	 g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	 b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	 rgbputb $r $g $b
	elif [ $1 = clear ]; then
	  printf "\033c"
	elif [ $1 = cols ]; then
	 echo $COLUMNS
	elif [ $1 = lines ]; then
	 echo $LINES
	elif [ $1 = pos ]; then
	 get_cursor_pos
	else
	 modeput 0 31; echo Error: unknow subcommand, printing help...; modeput 0 0
	 printhelp
	fi
}
bashbox_true() {
	#!/usr/bin/env bash
	#
	# true in pure bash.
	exit 0
}
bashbox_uname() {
	#!/usr/bin/env bash
	if [ -z $1 ]; then
		echo $OSTYPE
	elif [ $1 = -m ]; then
		printf '%s\n' "$HOSTTYPE"
	elif [ $1 = --type ]; then
		echo $MACHTYPE
	#elif [ $1 = -a ]; then linux only 
	#	printf '%s\n' "$(<"/proc/version")" linux only
	elif [ $1 = -n ]; then
		: '\h'
		printf '%s\n' "${_@P}"
	else 
		echo "flags: -m --type -n"
	fi
}
bashbox_uptime() {
	#!/usr/bin/env bash
	#
	# uptime in pure bash.
	
	: "$(</proc/uptime)"
	seconds_up=${_%%.*}
	if [[ "$#" == 0 ]]; then
	    printf ' %(%H:%M:%S)T up '
	    if [[ $((minutes_up)) -ge 1440 ]]; then
	        printf '%d days, ' $((minutes_up/1440))
	    fi
	    if [[ $((minutes_up)) -ge 60 ]]; then
	        printf '%2d:%02d' $((minutes_up%1440/60)) $((minutes_up%60))
	    else
	        printf '%d min' $minutes_up
	    fi 
	else
	    getopts sp options
	    case $options in
	        s) current_timestamp=$(printf '%(%s)T')
	           printf '%(%Y-%m-%d %H:%M:%S)T\n' $((current_timestamp-seconds_up));;
	        p) minutes_up=$((seconds_up/60))
	           printf 'up '
	           if [[ $((minutes_up)) -ge 60 ]]; then
	               printf '%d hours, ' $((minutes_up/60))
	           fi
	           printf '%d minutes\n' $((minutes_up%60));;
	        ?) echo "$0: invalid option -- '$options'
	Usage: $0 [-ps]">&2;;
	    esac
	fi
}
bashbox_vi() {
	#!/usr/bin/env bash
	### SETTINGS ###
	
	# this is what TAB will insert.
	# default value is "  ". possible values are any string.
	tabchar="	"
	
	# auto tab with bim_insert, bim_backinsert, or when ENTER is pressed in insert mode.
	# default value is "0". possible values are 0 or 1.
	autotab="0"
	line=0
	base=1
	version="bashbox vi (bim)"
	message="welcome to vi"
	unsaved_changes=0
	
	declare -a buffer
	declare -i line base
	declare file version message
	bind 'set disable-completion on' 2>/dev/null
	shopt -s checkwinsize; (:)
	trap refresh WINCH ALRM
	trap cleanup EXIT INT HUP USR1
	
	split() {
	   # Usage: split "string" "delimiter"
	   # thanks dylan araps :)
	   IFS=$'\n' read -d "" -ra arr <<< "${1//$2/$'\n'}"
	}
	
	keybinds() {
	            case "${key}" in
	            
	                # motions
	                k) bim_up 1;;
	                j) bim_down 1;;
	                K) bim_up $((LINES - 4));;
	                J) bim_down $((LINES - 4));;
	                g) bim_bof;;
	                G) bim_eof;;
	                t) cursor show
	                   bim_goto "$(misc_prompt "goto: ")"
	                   cursor hide
	                   ;;
	                
	                # editing
	                a|i) bim_edit;;
	                I) bim_prepend;;
	                d) bim_delete;;
	                c) bim_clear;;
	                o) bim_insert;;
	                O) bim_backinsert;;
	                n) bim_blank 1; bim_down 1;;
	                N) bim_backblank 1;;
	                y) bim_yank;;
	                p) bim_paste; bim_down 1;;
	            
	                # misc
	                :) bim_prompt;;
	                z) bim_center;;
	            
	            esac
	}
	        
	startup() {
	    cursor hide
	    cursor spos
	    cursor nowrap
	    cursor block
	}
	
	cleanup() {
	    cursor show
	    cursor rpos
	    cursor goto $LINES 0
	    cursor wrap
	    cursor block
	    exit 0
	}
	
	cursor() {
	    case "$1" in
	    save) printf "\e[?47h";;
	    load) printf "\e[?47l";;
	    spos) printf "\e7";;
	    rpos) printf "\e8\e[B";;
	    hide) printf "\e[?25l";;
	    show) printf "\e[?25h";;
	    goto) printf "\e[%s;%sf" "$2" "$3";;
	    wrap) printf "\e[?7h";;
	    nowrap) printf "\e[?7l";;
	    #beam) printf "\e[5 q";;
	    #block) printf "\e[1 q";;
	    #underline) printf "\e[3 q";;
	    esac
	}
	clear() {
		printf "\033c"
	}
	refresh() {
	    clear
	    #printf "\e[36m %s (%s Lines) %s %sx%s %s \e[m\n" \
	        #"$file" "${#buffer[@]}" "$version" "$LINES" "$COLUMNS" "$base"
	    for ((i=base; i-base < LINES-2; i++)); do
	        ((i !=  line))        && printf "\e[93m"     || printf "\e[31;1m"
	        ((i > ${#buffer[@]})) && printf "   ~\e[m\n" || printf "%4s\e[m %s\n" "$i" "${buffer[i]}"
	    done
	    if [ "$message" ]; then
	        printf "\e[32;1m%s\e[m\n" "$message"
	    else
	        printf "\e[36;1m%s [%s] %s/%s {%sx%s}\e[m\n" \
	            "$version" "${file}" "$line" "${#buffer[@]}" "$LINES" "$COLUMNS"
	    fi
	}
	
	bim_read() {
	    if [ "$1" ]; then
	        file="$1"
	    else
	        message="expected argument [FILE]"
	        return 1
	    fi
	
	    if [ -e "$file" ];then
	        mapfile -t -O 1 buffer <"$file"
	        message="Read ${#buffer[@]} lines from '$file'"
	    else
	        message="new file '$file'"
	    fi
	
	    [ ${#buffer[@]} -ne 0 ] && line=1
	}
	
	bim_write() {
	    if [ "$1" ]; then
	        myfile="$1"
	    elif [ "$file" ]; then
	        myfile="$file"
	    else
	        message="no file to write."
	        return 1
	    fi
	    : >"$myfile"
	    for wline in "${buffer[@]}"; do echo "$wline" >> "$myfile"; done
	    message="Wrote ${#buffer[@]} lines to '$myfile'"   
	    unsaved_changes=0
	}
	
	bim_up() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        ((line > 1))    && ((line--))
	    done
	}
	
	bim_down() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        ((line < ${#buffer[@]})) && ((line++))
	    done
	}
	
	bim_delete() {
	    lineyank="${buffer[line]}"
	    buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
	    unset "buffer[0]"
	    ((line > ${#buffer[@]})) && ((line--))
	    message="line cut."
	    unsaved_changes=1
	}
	
	bim_insert() {
	    buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
	    unset "buffer[0]"
	    ((line++))
	    # check if autotab is on and if the tab block we're extending starts with spaces
	    if [ $autotab = 1 ] && [ "${buffer[line-1]::1}" = " " ]; then
	        # wacky code to get the tab size of the last line
	        local lasttab="${buffer[line-1]%${buffer[line-1]##* }}"
	        # put in that same tab length to what we're going to edit
	        buffer[line]="$lasttab"
	    fi
	    # I have no clue why this has to be "-4" here
	    ((line > base+LINES-4))  && ((base++))
	    bim_edit
	}
	
	bim_backinsert() {
	    buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
	    unset "buffer[0]"
	    # same code as 'bim_insert'
	    if [ $autotab = 1 ] && [ "${buffer[line+1]::1}" = " " ]; then
	        local lasttab="${buffer[line+1]%${buffer[line+1]##* }}"
	        buffer[line]="$lasttab"
	    fi
	    bim_edit
	}
	
	bim_blank() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
	        unset "buffer[0]"
	    done
	}
	
	bim_backblank() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
	        unset "buffer[0]"
	    done
	}
	
	bim_yank() {
	    lineyank="${buffer[line]}"
	    message="line yanked."
	}
	
	bim_paste() {
	    buffer=([0]="" "${buffer[@]:1:line}" "$lineyank" "${buffer[@]:line+1}")
	    unset "buffer[0]"
	}
	
	bim_clear() {
	    ((line == 0)) && return
	    cursor goto $((line-base + 2)) 6
	    buffer[line]=""
	    unsaved_changes=1
	}
	
	# insert mode
	# my new robust replacement for 'read' that goes character by character
	bimput() { # <var> [starting string]
	    # starting text of line
	    local buf="$2"
	    local ch=""
	    cursor beam
	    cursor show
	    while true; do
	        IFS='' read -s -n1 ch
	        case "$ch" in
	            "")
	                bimputstatus="esc"
	                break
	                ;;
	            # read -n1 seems to interpret ENTER as nothing
	            "")
	                bimputstatus="enter"
	                break
	                ;;
	            # vscode is unable do display a backspace
	            # but there is one between these quotes
	            "")
	                if [ "$buf" ]; then
	                    buf="${buf%?}"
	                    printf "\b \b"
	                else
	                    bimputstatus="backline"
	                    break
	                fi
	                ;;
	            "	")
	                buf="${buf}${shiftwidth:="  "}"
	                echo -n "${shiftwidth}"
	                ;;
	            *)
	                buf="${buf}${ch}"
	                printf "$ch"
	                ;;
	        esac
	    done
	    eval "${1}=\${buf}"
	    cursor hide
	    cursor block
	}
	
	bim_edit() {
	    # refresh, as 'read' will freeze drawing
	    refresh
	    # make a line in an empty buffer
	    ((line == 0)) && buffer[1]="" && line=1 && refresh
	    # print '--INSERT--' at the bottom
	    cursor goto $LINES
	    printf "\e[32m%s\e[m" "--INSERT--"
	    # do the actual thing
	    cursor goto $((line-base + 1)) $((6 + ${#buffer[line]}))
	    bimput "buffer[line]" "${buffer[line]}"
	    case "$bimputstatus" in
	        "enter")
	            # nice and simple
	            bim_insert
	            ;;
	        "backline")
	            # delete line
	            buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
	            unset "buffer[0]"
	            # go back a line and edit
	            ((line--))
	            bim_edit
	            ;;
	    esac
	    unsaved_changes=1
	}
	
	bim_prepend() {
	    # refresh, as 'read' will freeze drawing
	    refresh
	    # make a line in an empty buffer
	    ((line == 0)) && buffer[1]="" && line=1 && refresh
	    # print '--INSERT--' at the bottom
	    cursor goto $LINES
	    printf "\e[32m%s\e[m" "--PREPEND--"
	    # do the actual thing
	    cursor goto $((line-base + 2)) 4
	    printf "^~"
	    cursor underline
	    cursor show
	    read -re
	    cursor hide
	    cursor block
	    # write $REPLY + what was already there
	    buffer[line]="${REPLY}${buffer[line]}"
	    unsaved_changes=1
	}
	
	bim_prompt() {
	    bind 'set disable-completion off' 2>/dev/null
	    cursor show
	    read -rep ":" choice
	    bind 'set disable-completion on' 2>/dev/null
	
	    # run command and wait
	    if [ "${choice::1}" = "!" ]; then
	        eval "${choice##!}"
	        cursor hide
	        printf "\e[31mpress any key to continue."
	        read -N1 -r
	    # read command output
	    elif [ "${choice::3}" = "r !" ]; then
	        eval "output=\"\$(${choice##r !})\""
	        split "$output" $'\n'
	        bim_blank ${#arr[@]}
	        i=0
	        while [ $i -lt ${#arr[@]} ]; do
	            buffer[line+i+1]="${arr[i]}"
	            unset "buffer[0]"
	            ((i++))
	        done
	        cursor hide
	        unsaved_changes=1
	    # simply run command
	    else
	        eval "$choice"
	        succ=$?
	        if [ ! "$(type -t ${choice%% *})" = "function" ]; then
	            message="finished with exit code $succ"
	        fi
	        cursor hide
	    fi
	    # cursor must be hidden in each case individually.
	}
	
	misc_prompt() {
	    # cursor must be shown externally
	    # as to not pass escape sequences into functions
	    [ "$1" ] || return 1
	    bind 'set disable-completion off' 2>/dev/null
	    read -rep "$1"
	    bind 'set disable-completion on' 2>/dev/null
	
	    printf '%s' "$REPLY"
	}
	
	quit() {
	    if [ "$unsaved_changes" = 0 ]; then
	        exit 0
	    else
	        message="unsaved changes. force quit with \":qq\""
	    fi
	}
	
	bim_bof() {
		[ ${#buffer[@]} = 0 ] && return 1
	    line=1
	}
	
	bim_eof() {
	    line=${#buffer[@]}
	}
	
	bim_goto() {
	    [ "$1" ] || return 1
	    [ ${#buffer[@]} -ge $1 ] && line=$1
	}
	
	bim_center() {
	    (( base=line-((LINES-3)/2) ))
	    [ $base -lt 1 ] && base=1
	}
	
	# functions that are really just aliases
	# and shortcuts for the command line
	
	w() {
	    bim_write "$@"
	}
	
	q() {
	    quit
	}
	
	qq() {
	    exit 0
	}
	
	wq() {
	    w "$@" && q
	}
	
	e() {
	    bim_read "$@"
	}
	
	
	keyboard_loop () {
	    startup
	    [ "$1" ] && bim_read "$1"
	    refresh
	
	    while true; do
	        read -rsN1 key
	        message=""
	
	        # iteration (only 2 digit numbers)
	        # cancel with ESC
	        case $key in
	            1|2|3|4|5|6|7|8|9)
	                digit1="$key"
	                printf '%d' "$key"
	                read -rsN1 key
	                case $key in
	                    1|2|3|4|5|6|7|8|9|0)
	                        digit2="$key"
	                        printf '%d' "$key"
	                        read -rsN1 key
	                        ;;
	                    "")
	                        digit1="1"
	                        digit2=""
	                        ;;
	                    *)
	                        digit2=""
	                        ;;
	                esac
	                ;;
	            "")
	                digit1="1"
	                digit2=""
	                ;;
	            *)
	                digit1="1"
	                digit2=""
	                ;;
	        esac
	
	        # compute keys from rc or defaults
	        # reiterate if applicable
	        kbj="${digit1}${digit2}"
	        for ((kbinc=0; kbinc < kbj; kbinc++)); do
	            keybinds
	        done
	
	        # universal scrolling system
	        if [ $base -gt $line ]; then
	            [ $base = 1 ] || base=$line
	        elif (( base+LINES-3 < line )); then
	            ((base=line-LINES+3))
	        fi
	
	        # refresh the UI
	        refresh
	    done
	    clear
	}
	
	usage () {
	echo '
	bim: bash vim
	
	usage: ${0##*/} [ options | file ]
	
	options:
	    -h|--help : print this help message
	    -k|--keys : print a basic usage document'
	}
	
	keys () {
	echo '# navigation
	  j - move down  (:bim_down [LINES])
	  k - page up    (:bim_up [LINES])
	  J - page down
	  K - page up
	  g - first line (:bim_bof)
	  G - last line  (:bim_eof)
	  t - go to line (:bim_goto [LINE])
	
	# editing
	  a - append to line  (:bim_edit)
	  I - prepend to line (:bim_prepend)
	  d - delete line     (:bim_delete)
	  c - clear line      (:bim_clear)
	  y - yank line       (:bim_yank)
	  p - paste line      (:bim_paste)
	  n - create line below (:bim_blank [LINES])
	  N - create line above (:bim_backblank [LINES])
	  o - create line below and edit (:bim_insert)
	  O - create line above and edit (:bim_backinsert)
	
	# commands
	# NOTE: the command line is for both editor and shell commands.
	   : - open command line
	  :w [FILE] - write to current or given file
	  :q - quit
	 :qq - force quit
	 :wq - write and quit
	  :e [FILE] - open file
	  :![COMMAND] - pause to view the output of a command
	:r ![COMMAND] - read output of a command'
	}
	
	
	
	main() {
	    case $1 in
	        -h|--help) trap : EXIT; usage;;
	        -k|--keys) trap : EXIT; keys;;
	        *) keyboard_loop "$1";;
	    esac
	}
	
	main "$@"
}
bashbox_wc() {
	#!/usr/bin/env bash
	#
	# wc in pure bash.
	
	while getopts "lcw" opt; do
	    case $opt in
	        l) lines=1 ;;
	        c) bytes=1 ;;
	        w) words=1 ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	done
	
	[[ -t 0 && -f ${*: -1} ]] &&
	    file=${*: -1}
	
	[[ -t 0 && ! -f $file ]] && {
	    printf '%s\n' "wc: ${file:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile file_data < "${file:-/dev/stdin}"
	
	for line in "${file_data[@]}"; do
	    read -ra line_split <<< "$line"
	    ((splits+=${#line_split[@]}, chars+=${#line}))
	done
	
	[[ -z $lines && -z $bytes && -z $words ]] &&
	    ((lines=1, bytes=1, words=1))
	
	[[ $lines ]] && printf '%s ' "${#file_data[@]}"
	[[ $words ]] && printf '%s ' "$splits"
	[[ $bytes ]] && printf '%s ' "$chars"
	
	printf '%s\n' "$file"
}
bashbox_whoami() {
	#!/usr/bin/env bash
	#
	# logname in pure bash.
	
	: '\u'
	printf '%s\n' "${_@P}"
}
bashbox_yes() {
	#!/usr/bin/env bash
	#
	# yes in pure bash.
	
	if [[ "$1" ]]; then
	    for ((;;)); {
	        printf '%s\n' "$1"
	    }
	else
	    for ((;;)); {
	        printf y\\n
	    }
	fi
}
alias arch=bashbox_arch
alias basename=bashbox_basename
alias cat=bashbox_cat
alias chr=bashbox_chr
alias clear=bashbox_clear
alias cp=bashbox_cp
alias curl=bashbox_curl
alias date=bashbox_date
alias dirname=bashbox_dirname
alias echo=bashbox_echo
alias env=bashbox_env
alias exec=bashbox_exec
alias expand=bashbox_expand
alias expr=bashbox_expr
alias false=bashbox_false
alias hd=bashbox_hd
alias head=bashbox_head
alias hostname=bashbox_hostname
alias locale=bashbox_locale
alias logname=bashbox_logname
alias ls=bashbox_ls
alias ord=bashbox_ord
alias printenv=bashbox_printenv
alias printf=bashbox_printf
alias pwd=bashbox_pwd
alias realpath=bashbox_realpath
alias seq=bashbox_seq
alias sh=bashbox_sh
alias sleep=bashbox_sleep
alias tac=bashbox_tac
alias tail=bashbox_tail
alias time=bashbox_time
alias touch=bashbox_touch
alias tput=bashbox_tput
alias true=bashbox_true
alias uname=bashbox_uname
alias uptime=bashbox_uptime
alias vi=bashbox_vi
alias wc=bashbox_wc
alias whoami=bashbox_whoami
alias yes=bashbox_yes
