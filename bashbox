#!/usr/bin/env bash
cmdf=$1
shift
if [[ a = b ]]; then
 exit
elif [[ $cmdf = arch ]]; then
	#!/usr/bin/env bash
	#
	# arch in pure bash.
	
	echo "$HOSTTYPE"
elif [[ $cmdf = basename ]]; then
	#!/usr/bin/env bash
	#
	# basename in pure bash.
	
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
elif [[ $cmdf = cat ]]; then
	#!/usr/bin/env bash
	#
	# cat in pure bash.
	
	if [[ "$#" == 0 ]]; then
	    while read -rn1; do echo "$REPLY"; done
	else
	    for file in "$@"; do
	        if [[ -f $file ]]; then
	            printf '%s\n' "$(<"$file")"
	        else
	            printf '%s\n' "cat: $file: No such file or directory" >&2
	        fi
	    done
	fi
elif [[ $cmdf = chr ]]; then
	chr() {
	  [ "$1" -lt 256 ] || return 1
	  printf "\\$(printf '%03o' "$1")"
	}
	
	chr "$@"
elif [[ $cmdf = clear ]]; then
	#!/usr/bin/env bas
	printf "\033c"
	#found this randomly and it seems to "work"
elif [[ $cmdf = cp ]]; then
	#!/bin/sh
	if [ -z $1 ]; then
	  echo "cp: missing file name"
	  exit
	fi
	if [ -z $2 ]; then
	  echo "cp: missing target file name"
	  exit
	fi
	if [ ! -f $1 ]; then
	  echo "cp: file not found"
	  exit
	fi
	printf '%s\n' "$(<"$1")" > $2
	#cp in pure sh
	#test
elif [[ $cmdf = curl ]]; then
	#!/usr/bin/env bash
	#
	# Download a file in pure bash.
	
	download() {
	    IFS=/ read -r _ _ host query <<< "$1"
	
	    # Send the HTTP request.
	    exec 3<"/dev/tcp/${host}/80"; {
	        printf '%s\r\n%s\r\n\r\n' \
	               "GET /${query} HTTP/1.0" \
	               "Host: $host"
	    } >&3
	
	    # Strip the HTTP headers.
	    while IFS= read -r line; do
	        [[ "$line" == $'\r' ]] && break
	    done <&3
	
	    # Output the file.
	    nul='\0'
	    while IFS= read -d '' -r line || { nul=""; [[ -n "$line" ]]; }; do
	        printf "%s%b" "$line" "$nul"
	    done <&3
	
	    exec 3>&-
	}
	
	if [ "$1" = "-o" ]; then
		download "$3" > "$2"
	else
		download "$1"
	fi
elif [[ $cmdf = date ]]; then
	#!/usr/bin/env bash
	#
	# date in pure bash.
	
	date_format="$1"
	
	[[ ${date_format:0:1} == + ]] &&
	    date_format="${date_format/+}"
	
	printf "%($date_format)T\\n"
elif [[ $cmdf = dirname ]]; then
	#!/usr/bin/env bash
	#
	# dirname in pure bash.
	
	for file in "$@"; do
	    printf '%s\n' "${file%/*}/"
	done
elif [[ $cmdf = echo ]]; then
	#!/usr/bin/env bash
	#
	# echo in pure bash.
	
	echo "$@"
elif [[ $cmdf = env ]]; then
	#!/usr/bin/env bash
	#
	# env in pure bash.
	
	mapfile -t envars < <(compgen -v)
	
	for var in "${envars[@]}"; do
	    printf '%s=%s\n' "$var" "${!var}"
	done
elif [[ $cmdf = exec ]]; then
	#!/usr/bin/env bash
	shift
	$@
	exit
elif [[ $cmdf = expand ]]; then
	#!/usr/bin/env bash
	#
	# expand in pure bash.
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "expand: $1: No such file or directory." >&2
	    exit 1
	}
	
	file="$(< "$1")"
	printf '%s\n' "${file//$'\t'/'        '}"
elif [[ $cmdf = expr ]]; then
	#!/usr/bin/env bash
	#
	# expr in pure bash.
	
	printf '%s\n' "$(($@))"
elif [[ $cmdf = false ]]; then
	#!/usr/bin/env bash
	#
	# false in pure bash.
	
	exit 1
elif [[ $cmdf = hd ]]; then
	#!/usr/bin/env bash
	hd() {
	  if (($#)); then
	    hd <"$1"
	    return
	  fi
	  local IFS='' # disables interpretation of \t, \n and space
	  local LANG=C # allows characters > 0x7F
	  local bytes=0 char chars=''
	  declare -i bytes
	  printf '%08x  ' 0
	  while read -s -d '' -r -n 1 char; do  # -d '' allows newlines, -r allows \
	    printf '%02x ' "'$char" # see https://pubs.opengroup.org/onlinepubs/009695399/utilities/printf.html
	    [[ "$char" =~ [[:print:]] ]] || char='.' # display non-printables as a dot
	    chars+=$char
	    ((++bytes % 8)) && continue
	    printf ' '
	    ((bytes % 16)) && continue
	    printf '|%s|\n%08x  ' "$chars" "$bytes"
	    chars=''
	  done
	  if [[ "$chars" ]]; then
	    len=${#chars}
	    ((len > 7 && len--, len += (16 - (bytes % 16)) * 3 + 4))
	    printf "%${len}s\n%08x  " "|$chars|" "$bytes"
	  fi
	  printf '\n'
	}
	
	hd "$@"
elif [[ $cmdf = head ]]; then
	#!/usr/bin/env bash
	#
	# head in pure bash.
	
	while getopts ":n:" opt; do
	    case $opt in
	        n) max_lines="$OPTARG" ;;
	
	        :)
	            printf '%s\n' "option -$OPTARG requires an argument." >&2
	            exit 1
	        ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	
	    shift "$((OPTIND - 1))"
	done
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "head: ${1:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile -n "${max_lines:-10}" file_data < "$1"
	printf '%s' "${file_data[@]}"
elif [[ $cmdf = hostname ]]; then
	#!/usr/bin/env bash
	#
	# hostname in pure bash.
	
	: '\h'
	printf '%s\n' "${_@P}"
elif [[ $cmdf = locale ]]; then
	#!/usr/bin/env bash
	#
	# locale in pure bash.
	
	locale_vars=(
	    LANG
	    LC_CTYPE
	    LC_NUMERIC
	    LC_TIME
	    LC_COLLATE
	    LC_MONETARY
	    LC_MESSAGES
	    LC_PAPER
	    LC_NAME
	    LC_ADDRESS
	    LC_TELEPHONE
	    LC_MEASUREMENT
	    LC_IDENTIFICATION
	)
	
	
	for var in "${locale_vars[@]}"; do
	    printf '%s=\"%s\"\n' "$var" "${!var:-$LANG}"
	done
	printf '%s=%s\n' "LC_ALL" "$LC_ALL"
elif [[ $cmdf = logname ]]; then
	#!/usr/bin/env bash
	#
	# logname in pure bash.
	
	: '\u'
	printf '%s\n' "${_@P}"
elif [[ $cmdf = ls ]]; then
	#!/usr/bin/bash
	#found this randomly and it kinda works
	printf '%s\n' *
elif [[ $cmdf = ord ]]; then
	ord() {
	  LC_CTYPE=C printf '%d' "'$1"
	}
	ord "$@"
elif [[ $cmdf = printenv ]]; then
	#!/usr/bin/env bash
	#
	# printenv in pure bash.
	
	[[ $1 ]] && {
	    printf '%s\n' "${!1}"
	    exit 0
	}
	
	mapfile -t envars < <(compgen -v)
	
	for var in "${envars[@]}"; do
	    printf '%s=%s\n' "$var" "${!var}"
	done
elif [[ $cmdf = printf ]]; then
	#!/usr/bin/env bash
	#
	# printf in pure bash.
	
	printf "$@"
elif [[ $cmdf = pwd ]]; then
	#!/usr/bin/env bash
	#
	# pwd in pure bash.
	
	printf '%s\n' "$PWD"
elif [[ $cmdf = realpath ]]; then
	#!/usr/bin/env bash
	#
	# realpath in pure bash.
	
	file="${1%/}"
	parent_dir="${file%/*}"
	
	[[ -f ${PWD}/${file##*/} ]] && {
	    printf '%s\n' "${PWD}/${file##*/}"
	    exit 0
	}
	
	cd "$parent_dir" &>/dev/null || exit 1 &&
	    printf '%s\n' "${PWD}/${file##*/}"
elif [[ $cmdf = seq ]]; then
	#!/usr/bin/env bash
	#
	# seq in pure bash.
	
	[[ -z $1 ]] && {
	    printf '%s\n' "seq: error: missing arguments." >&2
	    exit 1
	}
	
	[[ $2 ]] &&
	    first="$1"
	
	[[ $3 ]] &&
	    increment="$2"
	
	last="${*: -1}"
	
	for ((i=${first:=1};i<=last;i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
elif [[ $cmdf = sh ]]; then
	#!/usr/bin/env bash
	bash --posix $@
elif [[ $cmdf = sleep ]]; then
	#!/usr/bin/env bash
	if [ -z $1 ]; then
	  echo "sleep: syntax error"
	  exit
	fi
	read -d "" -rt $1
elif [[ $cmdf = tac ]]; then
	#!/usr/bin/env bash
	for file in "$@"
	do
		i=0 
		
		while read line[$i] ; do
		    i=$(($i+1))
		done < $file
		
		
		for (( i=${#line[@]}-1 ; i>=0 ; i-- )) ; do
		    echo ${line[$i]}
		done
	done
elif [[ $cmdf = tail ]]; then
	#!/usr/bin/env bash
	#
	# tail in pure bash.
	
	while getopts ":n:" opt; do
	    case $opt in
	        n) max_lines="$OPTARG" ;;
	
	        :)
	            printf '%s\n' "option -$OPTARG requires an argument." >&2
	            exit 1
	        ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	
	    shift "$((OPTIND - 1))"
	done
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "tail: ${1:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile -tn 0 file_data < "$1"
	
	[[ ${max_lines:=0} -gt "${#file_data[@]}" ]] &&
	    max_lines="${#file_data[@]}"
	
	printf '%s\n' "${file_data[@]: -$max_lines}"
elif [[ $cmdf = time ]]; then
	$@
	echo "$SECONDS"
elif [[ $cmdf = touch ]]; then
	#!/usr/bin/env bash
	#touch in pure bash
	if [ ! -f $1 ]; then
	 >$1
	fi
elif [[ $cmdf = tput ]]; then
	#!/usr/bin/env bash
	shopt -s checkwinsize; (:;:)
	printhelp() {
	 echo "Usage: tput [command]
	colors:
	 16 colors:
	  native:
	   set - set color and property
	   set 0 0 - reset terminal
	  tput mode:
	   setaf - set foreground color
	   setab - set background color
	   sgr0 - reset terminal
	  256 colors:
	  esetf - set foreground color 
	  esetb - set backgroud color
	 24-bit colors:
	  rgb format:
	   rsetf - set foreground color
	   rsetb - set background color
	  hex format:
	   hsetf - set foreground color
	   hsetb - set background color
	cursor:
	 moving:
	  cup - moves cursor to given position
	etc:
	 patch - replaces tput in script with cput (does not always work)
	info:
	 cols - width of terminal
	 lines - height of terminal
	 pos - position of cursor
	 "
	}
	##colors
	get_cursor_pos() {
	    # Usage: get_cursor_pos
	    IFS='[;' read -p $'\e[6n' -d R -rs _ y x _
	    printf '%s\n' "$y $x"
	}
	modeput() {
	 printf "\033[$1;$2m"
	}
	rgbputf() {
	 printf "\033[38;2;$1;$2;$3m"
	}
	rgbputb() {
	 printf "\033[48;2;$1;$2;$3m"
	}
	if [ -z $1 ]; then
	 printhelp
	elif [ $1 = rsetf ]; then
	 printf "\033[38;2;$2;$3;$4m"
	elif [ $1 = rsetb ]; then
	 printf "\033[48;2;$2;$3;$4m"
	elif [ $1 = esetf ]; then
	 printf "\033[38;5;$2m"
	elif [ $1 = esetb ]; then
	 printf "\033[48;5;$2m"
	elif [ $1 = set ]; then
	 modeput $2 $3
	elif [ $1 = setaf ]; then
	 if [ $2 = 0 ]; then
	  modeput 0 30
	 elif [ $2 = 1 ]; then
	  modeput 0 31
	 elif [ $2 = 2 ]; then
	  modeput 0 32
	 elif [ $2 = 3 ]; then
	  modeput 0 33
	 elif [ $2 = 4 ]; then
	  modeput 0 34
	 elif [ $2 = 5 ]; then
	  modeput 0 35
	 elif [ $2 = 6 ]; then
	  modeput 0 36
	 elif [ $2 = 7 ]; then
	  modeput 0 37
	 elif [ $2 = 8 ]; then
	  modeput 0 90
	 elif [ $2 = 9 ]; then
	  modeput 0 91
	 elif [ $2 = 10 ]; then
	  modeput 0 92
	 elif [ $2 = 11 ]; then
	  modeput 0 93
	 elif [ $2 = 12 ]; then
	  modeput 0 94
	 elif [ $2 = 13 ]; then
	  modeput 0 95
	 elif [ $2 = 14 ]; then
	  modeput 0 96
	 elif [ $2 = 15 ]; then
	  modeput 0 97
	 elif [ $2 = 16 ]; then
	  modeput 0 98
	 else
	  modeput 0 31;echo cput: tput-mode: unknown color; modeput 0 0
	 fi
	elif [ $1 = setab ]; then
	 if [ $2 = 0 ]; then
	  modeput 0 40
	 elif [ $2 = 1 ]; then
	  modeput 0 41
	 elif [ $2 = 2 ]; then
	  modeput 0 42
	 elif [ $2 = 3 ]; then
	  modeput 0 43
	 elif [ $2 = 4 ]; then
	  modeput 0 44
	 elif [ $2 = 5 ]; then
	  modeput 0 45
	 elif [ $2 = 6 ]; then
	  modeput 0 46
	 elif [ $2 = 7 ]; then
	  modeput 0 47
	 elif [ $2 = 8 ]; then
	  modeput 0 100
	 elif [ $2 = 9 ]; then
	  modeput 0 101
	 elif [ $2 = 10 ]; then
	  modeput 0 102
	 elif [ $2 = 11 ]; then
	  modeput 0 103
	 elif [ $2 = 12 ]; then
	  modeput 0 104
	 elif [ $2 = 13 ]; then
	  modeput 0 105
	 elif [ $2 = 14 ]; then
	  modeput 0 106
	 elif [ $2 = 15 ]; then
	  modeput 0 107
	 elif [ $2 = 16 ]; then
	  modeput 0 108
	 else
	  modeput 0 41;echo cput: tput-mode: unknown color; modeput 0 0
	 fi
	elif [ $1 = sgr0 ]; then
	 modeput 0 0
	elif [ $1 = patch ]; then
	 sed -i 's/tput/cput/g' $2
	elif [ $1 = cup ]; then
	 printf "\033[$2;$3H"
	elif [ $1 = hsetf ]; then
	 r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	 g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	 b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	 rgbputf $r $g $b
	elif [ $1 = hsetb ]; then
	 r=$(printf "%d" "0x$(echo $2 | cut -c 1-2)")
	 g=$(printf "%d" "0x$(echo $2 | cut -c 3-4)")
	 b=$(printf "%d" "0x$(echo $2 | cut -c 5-6)")
	 rgbputb $r $g $b
	elif [ $1 = clear ]; then
	  printf "\033c"
	elif [ $1 = cols ]; then
	 echo $COLUMNS
	elif [ $1 = lines ]; then
	 echo $LINES
	elif [ $1 = pos ]; then
	 get_cursor_pos
	else
	 modeput 0 31; echo Error: unknow subcommand, printing help...; modeput 0 0
	 printhelp
	fi
elif [[ $cmdf = true ]]; then
	#!/usr/bin/env bash
	#
	# true in pure bash.
	exit 0
elif [[ $cmdf = uname ]]; then
	#!/usr/bin/env bash
	if [ -z $1 ]; then
		echo $OSTYPE
	elif [ $1 = -m ]; then
		printf '%s\n' "$HOSTTYPE"
	elif [ $1 = --type ]; then
		echo $MACHTYPE
	#elif [ $1 = -a ]; then linux only 
	#	printf '%s\n' "$(<"/proc/version")" linux only
	elif [ $1 = -n ]; then
		: '\h'
		printf '%s\n' "${_@P}"
	else 
		echo "flags: -m --type -n"
	fi
elif [[ $cmdf = uptime ]]; then
	#!/usr/bin/env bash
	#
	# uptime in pure bash.
	
	: "$(</proc/uptime)"
	seconds_up=${_%%.*}
	if [[ "$#" == 0 ]]; then
	    printf ' %(%H:%M:%S)T up '
	    if [[ $((minutes_up)) -ge 1440 ]]; then
	        printf '%d days, ' $((minutes_up/1440))
	    fi
	    if [[ $((minutes_up)) -ge 60 ]]; then
	        printf '%2d:%02d' $((minutes_up%1440/60)) $((minutes_up%60))
	    else
	        printf '%d min' $minutes_up
	    fi 
	else
	    getopts sp options
	    case $options in
	        s) current_timestamp=$(printf '%(%s)T')
	           printf '%(%Y-%m-%d %H:%M:%S)T\n' $((current_timestamp-seconds_up));;
	        p) minutes_up=$((seconds_up/60))
	           printf 'up '
	           if [[ $((minutes_up)) -ge 60 ]]; then
	               printf '%d hours, ' $((minutes_up/60))
	           fi
	           printf '%d minutes\n' $((minutes_up%60));;
	        ?) echo "$0: invalid option -- '$options'
	Usage: $0 [-ps]">&2;;
	    esac
	fi
elif [[ $cmdf = vi ]]; then
	#!/usr/bin/env bash
	### SETTINGS ###
	
	# this is what TAB will insert.
	# default value is "  ". possible values are any string.
	tabchar="	"
	
	# auto tab with bim_insert, bim_backinsert, or when ENTER is pressed in insert mode.
	# default value is "0". possible values are 0 or 1.
	autotab="0"
	line=0
	base=1
	version="bashbox vi (bim)"
	message="welcome to vi"
	unsaved_changes=0
	
	declare -a buffer
	declare -i line base
	declare file version message
	bind 'set disable-completion on' 2>/dev/null
	shopt -s checkwinsize; (:)
	trap refresh WINCH ALRM
	trap cleanup EXIT INT HUP USR1
	
	split() {
	   # Usage: split "string" "delimiter"
	   # thanks dylan araps :)
	   IFS=$'\n' read -d "" -ra arr <<< "${1//$2/$'\n'}"
	}
	
	keybinds() {
	            case "${key}" in
	            
	                # motions
	                k) bim_up 1;;
	                j) bim_down 1;;
	                K) bim_up $((LINES - 4));;
	                J) bim_down $((LINES - 4));;
	                g) bim_bof;;
	                G) bim_eof;;
	                t) cursor show
	                   bim_goto "$(misc_prompt "goto: ")"
	                   cursor hide
	                   ;;
	                
	                # editing
	                a|i) bim_edit;;
	                I) bim_prepend;;
	                d) bim_delete;;
	                c) bim_clear;;
	                o) bim_insert;;
	                O) bim_backinsert;;
	                n) bim_blank 1; bim_down 1;;
	                N) bim_backblank 1;;
	                y) bim_yank;;
	                p) bim_paste; bim_down 1;;
	            
	                # misc
	                :) bim_prompt;;
	                z) bim_center;;
	            
	            esac
	}
	        
	startup() {
	    cursor hide
	    cursor spos
	    cursor nowrap
	    cursor block
	}
	
	cleanup() {
	    cursor show
	    cursor rpos
	    cursor goto $LINES 0
	    cursor wrap
	    cursor block
	    exit 0
	}
	
	cursor() {
	    case "$1" in
	    save) printf "\e[?47h";;
	    load) printf "\e[?47l";;
	    spos) printf "\e7";;
	    rpos) printf "\e8\e[B";;
	    hide) printf "\e[?25l";;
	    show) printf "\e[?25h";;
	    goto) printf "\e[%s;%sf" "$2" "$3";;
	    wrap) printf "\e[?7h";;
	    nowrap) printf "\e[?7l";;
	    #beam) printf "\e[5 q";;
	    #block) printf "\e[1 q";;
	    #underline) printf "\e[3 q";;
	    esac
	}
	clear() {
		printf "\033c"
	}
	refresh() {
	    clear
	    #printf "\e[36m %s (%s Lines) %s %sx%s %s \e[m\n" \
	        #"$file" "${#buffer[@]}" "$version" "$LINES" "$COLUMNS" "$base"
	    for ((i=base; i-base < LINES-2; i++)); do
	        ((i !=  line))        && printf "\e[93m"     || printf "\e[31;1m"
	        ((i > ${#buffer[@]})) && printf "   ~\e[m\n" || printf "%4s\e[m %s\n" "$i" "${buffer[i]}"
	    done
	    if [ "$message" ]; then
	        printf "\e[32;1m%s\e[m\n" "$message"
	    else
	        printf "\e[36;1m%s [%s] %s/%s {%sx%s}\e[m\n" \
	            "$version" "${file}" "$line" "${#buffer[@]}" "$LINES" "$COLUMNS"
	    fi
	}
	
	bim_read() {
	    if [ "$1" ]; then
	        file="$1"
	    else
	        message="expected argument [FILE]"
	        return 1
	    fi
	
	    if [ -e "$file" ];then
	        mapfile -t -O 1 buffer <"$file"
	        message="Read ${#buffer[@]} lines from '$file'"
	    else
	        message="new file '$file'"
	    fi
	
	    [ ${#buffer[@]} -ne 0 ] && line=1
	}
	
	bim_write() {
	    if [ "$1" ]; then
	        myfile="$1"
	    elif [ "$file" ]; then
	        myfile="$file"
	    else
	        message="no file to write."
	        return 1
	    fi
	    : >"$myfile"
	    for wline in "${buffer[@]}"; do echo "$wline" >> "$myfile"; done
	    message="Wrote ${#buffer[@]} lines to '$myfile'"   
	    unsaved_changes=0
	}
	
	bim_up() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        ((line > 1))    && ((line--))
	    done
	}
	
	bim_down() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        ((line < ${#buffer[@]})) && ((line++))
	    done
	}
	
	bim_delete() {
	    lineyank="${buffer[line]}"
	    buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
	    unset "buffer[0]"
	    ((line > ${#buffer[@]})) && ((line--))
	    message="line cut."
	    unsaved_changes=1
	}
	
	bim_insert() {
	    buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
	    unset "buffer[0]"
	    ((line++))
	    # check if autotab is on and if the tab block we're extending starts with spaces
	    if [ $autotab = 1 ] && [ "${buffer[line-1]::1}" = " " ]; then
	        # wacky code to get the tab size of the last line
	        local lasttab="${buffer[line-1]%${buffer[line-1]##* }}"
	        # put in that same tab length to what we're going to edit
	        buffer[line]="$lasttab"
	    fi
	    # I have no clue why this has to be "-4" here
	    ((line > base+LINES-4))  && ((base++))
	    bim_edit
	}
	
	bim_backinsert() {
	    buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
	    unset "buffer[0]"
	    # same code as 'bim_insert'
	    if [ $autotab = 1 ] && [ "${buffer[line+1]::1}" = " " ]; then
	        local lasttab="${buffer[line+1]%${buffer[line+1]##* }}"
	        buffer[line]="$lasttab"
	    fi
	    bim_edit
	}
	
	bim_blank() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        buffer=([0]="" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
	        unset "buffer[0]"
	    done
	}
	
	bim_backblank() {
	    [ "$1" ] && num="$1" || num=1
	    for ((i=0;i<$num;i++)); do
	        buffer=([0]="" "${buffer[@]:1:line-1}" "" "${buffer[@]:line}")
	        unset "buffer[0]"
	    done
	}
	
	bim_yank() {
	    lineyank="${buffer[line]}"
	    message="line yanked."
	}
	
	bim_paste() {
	    buffer=([0]="" "${buffer[@]:1:line}" "$lineyank" "${buffer[@]:line+1}")
	    unset "buffer[0]"
	}
	
	bim_clear() {
	    ((line == 0)) && return
	    cursor goto $((line-base + 2)) 6
	    buffer[line]=""
	    unsaved_changes=1
	}
	
	# insert mode
	# my new robust replacement for 'read' that goes character by character
	bimput() { # <var> [starting string]
	    # starting text of line
	    local buf="$2"
	    local ch=""
	    cursor beam
	    cursor show
	    while true; do
	        IFS='' read -s -n1 ch
	        case "$ch" in
	            "")
	                bimputstatus="esc"
	                break
	                ;;
	            # read -n1 seems to interpret ENTER as nothing
	            "")
	                bimputstatus="enter"
	                break
	                ;;
	            # vscode is unable do display a backspace
	            # but there is one between these quotes
	            "")
	                if [ "$buf" ]; then
	                    buf="${buf%?}"
	                    printf "\b \b"
	                else
	                    bimputstatus="backline"
	                    break
	                fi
	                ;;
	            "	")
	                buf="${buf}${shiftwidth:="  "}"
	                echo -n "${shiftwidth}"
	                ;;
	            *)
	                buf="${buf}${ch}"
	                printf "$ch"
	                ;;
	        esac
	    done
	    eval "${1}=\${buf}"
	    cursor hide
	    cursor block
	}
	
	bim_edit() {
	    # refresh, as 'read' will freeze drawing
	    refresh
	    # make a line in an empty buffer
	    ((line == 0)) && buffer[1]="" && line=1 && refresh
	    # print '--INSERT--' at the bottom
	    cursor goto $LINES
	    printf "\e[32m%s\e[m" "--INSERT--"
	    # do the actual thing
	    cursor goto $((line-base + 1)) $((6 + ${#buffer[line]}))
	    bimput "buffer[line]" "${buffer[line]}"
	    case "$bimputstatus" in
	        "enter")
	            # nice and simple
	            bim_insert
	            ;;
	        "backline")
	            # delete line
	            buffer=([0]="" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
	            unset "buffer[0]"
	            # go back a line and edit
	            ((line--))
	            bim_edit
	            ;;
	    esac
	    unsaved_changes=1
	}
	
	bim_prepend() {
	    # refresh, as 'read' will freeze drawing
	    refresh
	    # make a line in an empty buffer
	    ((line == 0)) && buffer[1]="" && line=1 && refresh
	    # print '--INSERT--' at the bottom
	    cursor goto $LINES
	    printf "\e[32m%s\e[m" "--PREPEND--"
	    # do the actual thing
	    cursor goto $((line-base + 2)) 4
	    printf "^~"
	    cursor underline
	    cursor show
	    read -re
	    cursor hide
	    cursor block
	    # write $REPLY + what was already there
	    buffer[line]="${REPLY}${buffer[line]}"
	    unsaved_changes=1
	}
	
	bim_prompt() {
	    bind 'set disable-completion off' 2>/dev/null
	    cursor show
	    read -rep ":" choice
	    bind 'set disable-completion on' 2>/dev/null
	
	    # run command and wait
	    if [ "${choice::1}" = "!" ]; then
	        eval "${choice##!}"
	        cursor hide
	        printf "\e[31mpress any key to continue."
	        read -N1 -r
	    # read command output
	    elif [ "${choice::3}" = "r !" ]; then
	        eval "output=\"\$(${choice##r !})\""
	        split "$output" $'\n'
	        bim_blank ${#arr[@]}
	        i=0
	        while [ $i -lt ${#arr[@]} ]; do
	            buffer[line+i+1]="${arr[i]}"
	            unset "buffer[0]"
	            ((i++))
	        done
	        cursor hide
	        unsaved_changes=1
	    # simply run command
	    else
	        eval "$choice"
	        succ=$?
	        if [ ! "$(type -t ${choice%% *})" = "function" ]; then
	            message="finished with exit code $succ"
	        fi
	        cursor hide
	    fi
	    # cursor must be hidden in each case individually.
	}
	
	misc_prompt() {
	    # cursor must be shown externally
	    # as to not pass escape sequences into functions
	    [ "$1" ] || return 1
	    bind 'set disable-completion off' 2>/dev/null
	    read -rep "$1"
	    bind 'set disable-completion on' 2>/dev/null
	
	    printf '%s' "$REPLY"
	}
	
	quit() {
	    if [ "$unsaved_changes" = 0 ]; then
	        exit 0
	    else
	        message="unsaved changes. force quit with \":qq\""
	    fi
	}
	
	bim_bof() {
		[ ${#buffer[@]} = 0 ] && return 1
	    line=1
	}
	
	bim_eof() {
	    line=${#buffer[@]}
	}
	
	bim_goto() {
	    [ "$1" ] || return 1
	    [ ${#buffer[@]} -ge $1 ] && line=$1
	}
	
	bim_center() {
	    (( base=line-((LINES-3)/2) ))
	    [ $base -lt 1 ] && base=1
	}
	
	# functions that are really just aliases
	# and shortcuts for the command line
	
	w() {
	    bim_write "$@"
	}
	
	q() {
	    quit
	}
	
	qq() {
	    exit 0
	}
	
	wq() {
	    w "$@" && q
	}
	
	e() {
	    bim_read "$@"
	}
	
	
	keyboard_loop () {
	    startup
	    [ "$1" ] && bim_read "$1"
	    refresh
	
	    while true; do
	        read -rsN1 key
	        message=""
	
	        # iteration (only 2 digit numbers)
	        # cancel with ESC
	        case $key in
	            1|2|3|4|5|6|7|8|9)
	                digit1="$key"
	                printf '%d' "$key"
	                read -rsN1 key
	                case $key in
	                    1|2|3|4|5|6|7|8|9|0)
	                        digit2="$key"
	                        printf '%d' "$key"
	                        read -rsN1 key
	                        ;;
	                    "")
	                        digit1="1"
	                        digit2=""
	                        ;;
	                    *)
	                        digit2=""
	                        ;;
	                esac
	                ;;
	            "")
	                digit1="1"
	                digit2=""
	                ;;
	            *)
	                digit1="1"
	                digit2=""
	                ;;
	        esac
	
	        # compute keys from rc or defaults
	        # reiterate if applicable
	        kbj="${digit1}${digit2}"
	        for ((kbinc=0; kbinc < kbj; kbinc++)); do
	            keybinds
	        done
	
	        # universal scrolling system
	        if [ $base -gt $line ]; then
	            [ $base = 1 ] || base=$line
	        elif (( base+LINES-3 < line )); then
	            ((base=line-LINES+3))
	        fi
	
	        # refresh the UI
	        refresh
	    done
	    clear
	}
	
	usage () {
	echo '
	bim: bash vim
	
	usage: ${0##*/} [ options | file ]
	
	options:
	    -h|--help : print this help message
	    -k|--keys : print a basic usage document'
	}
	
	keys () {
	echo '# navigation
	  j - move down  (:bim_down [LINES])
	  k - page up    (:bim_up [LINES])
	  J - page down
	  K - page up
	  g - first line (:bim_bof)
	  G - last line  (:bim_eof)
	  t - go to line (:bim_goto [LINE])
	
	# editing
	  a - append to line  (:bim_edit)
	  I - prepend to line (:bim_prepend)
	  d - delete line     (:bim_delete)
	  c - clear line      (:bim_clear)
	  y - yank line       (:bim_yank)
	  p - paste line      (:bim_paste)
	  n - create line below (:bim_blank [LINES])
	  N - create line above (:bim_backblank [LINES])
	  o - create line below and edit (:bim_insert)
	  O - create line above and edit (:bim_backinsert)
	
	# commands
	# NOTE: the command line is for both editor and shell commands.
	   : - open command line
	  :w [FILE] - write to current or given file
	  :q - quit
	 :qq - force quit
	 :wq - write and quit
	  :e [FILE] - open file
	  :![COMMAND] - pause to view the output of a command
	:r ![COMMAND] - read output of a command'
	}
	
	
	
	main() {
	    case $1 in
	        -h|--help) trap : EXIT; usage;;
	        -k|--keys) trap : EXIT; keys;;
	        *) keyboard_loop "$1";;
	    esac
	}
	
	main "$@"
elif [[ $cmdf = wc ]]; then
	#!/usr/bin/env bash
	#
	# wc in pure bash.
	
	while getopts "lcw" opt; do
	    case $opt in
	        l) lines=1 ;;
	        c) bytes=1 ;;
	        w) words=1 ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	done
	
	[[ -t 0 && -f ${*: -1} ]] &&
	    file=${*: -1}
	
	[[ -t 0 && ! -f $file ]] && {
	    printf '%s\n' "wc: ${file:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile file_data < "${file:-/dev/stdin}"
	
	for line in "${file_data[@]}"; do
	    read -ra line_split <<< "$line"
	    ((splits+=${#line_split[@]}, chars+=${#line}))
	done
	
	[[ -z $lines && -z $bytes && -z $words ]] &&
	    ((lines=1, bytes=1, words=1))
	
	[[ $lines ]] && printf '%s ' "${#file_data[@]}"
	[[ $words ]] && printf '%s ' "$splits"
	[[ $bytes ]] && printf '%s ' "$chars"
	
	printf '%s\n' "$file"
elif [[ $cmdf = whoami ]]; then
	#!/usr/bin/env bash
	#
	# logname in pure bash.
	
	: '\u'
	printf '%s\n' "${_@P}"
elif [[ $cmdf = yes ]]; then
	#!/usr/bin/env bash
	#
	# yes in pure bash.
	
	if [[ "$1" ]]; then
	    for ((;;)); {
	        printf '%s\n' "$1"
	    }
	else
	    for ((;;)); {
	        printf y\\n
	    }
	fi
else
 echo arch basename cat chr clear cp curl date dirname echo env exec expand expr false hd head hostname locale logname ls ord printenv printf pwd realpath seq sh sleep tac tail time touch tput true uname uptime vi wc whoami yes
fi
