#!/usr/bin/env bash
cmdf=$1
shift
if [[ a = b ]]; then
 exit
elif [[ $cmdf = arch ]]; then
	#!/usr/bin/env bash
	#
	# arch in pure bash.
	
	printf '%s\n' "${MACHTYPE%%-*}"
elif [[ $cmdf = basename ]]; then
	#!/usr/bin/env bash
	#
	# basename in pure bash.
	
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
elif [[ $cmdf = cat ]]; then
	#!/usr/bin/env bash
	#
	# cat in pure bash.
	
	if [[ "$#" == 0 ]]; then
	    while read -rn1; do echo "$REPLY"; done
	else
	    for file in "$@"; do
	        if [[ -f $file ]]; then
	            printf '%s\n' "$(<"$file")"
	        else
	            printf '%s\n' "cat: $file: No such file or directory" >&2
	        fi
	    done
	fi
elif [[ $cmdf = clear ]]; then
	#!/usr/bin/env bas
	printf "\033c"
	#found this randomly and it seems to "work"
elif [[ $cmdf = cp ]]; then
	#!/bin/sh
	if [ -z $1 ]; then
	  echo "cp: missing file name"
	  exit
	fi
	if [ -z $2 ]; then
	  echo "cp: missing target file name"
	  exit
	fi
	if [ ! -f $1 ]; then
	  echo "cp: file not found"
	  exit
	fi
	printf '%s\n' "$(<"$1")" > $2
	#cp in pure sh
	#test
elif [[ $cmdf = date ]]; then
	#!/usr/bin/env bash
	#
	# date in pure bash.
	
	date_format="$1"
	
	[[ ${date_format:0:1} == + ]] &&
	    date_format="${date_format/+}"
	
	printf "%($date_format)T\\n"
elif [[ $cmdf = dirname ]]; then
	#!/usr/bin/env bash
	#
	# dirname in pure bash.
	
	for file in "$@"; do
	    printf '%s\n' "${file%/*}/"
	done
elif [[ $cmdf = echo ]]; then
	#!/usr/bin/env bash
	#
	# echo in pure bash.
	
	echo "$@"
elif [[ $cmdf = env ]]; then
	#!/usr/bin/env bash
	#
	# env in pure bash.
	
	mapfile -t envars < <(compgen -v)
	
	for var in "${envars[@]}"; do
	    printf '%s=%s\n' "$var" "${!var}"
	done
elif [[ $cmdf = exec ]]; then
	#!/usr/bin/env bash
	shift
	$@
	exit
elif [[ $cmdf = expand ]]; then
	#!/usr/bin/env bash
	#
	# expand in pure bash.
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "expand: $1: No such file or directory." >&2
	    exit 1
	}
	
	file="$(< "$1")"
	printf '%s\n' "${file//$'\t'/'        '}"
elif [[ $cmdf = expr ]]; then
	#!/usr/bin/env bash
	#
	# expr in pure bash.
	
	printf '%s\n' "$(($@))"
elif [[ $cmdf = false ]]; then
	#!/usr/bin/env bash
	#
	# false in pure bash.
	
	exit 1
elif [[ $cmdf = head ]]; then
	#!/usr/bin/env bash
	#
	# head in pure bash.
	
	max_lines=10
	
	while getopts ":n:" opt; do
	    case $opt in
	        n) max_lines="$OPTARG" ;;
	
	        :)
	            printf '%s\n' "option -$OPTARG requires an argument." >&2
	            exit 1
	        ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	
	    shift "$((OPTIND - 1))"
	done
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "head: ${1:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile file_data < "$1"
	[[ ${max_lines##-*} || $((max_lines += ${#file_data[@]})) ]]
	printf '%s' "${file_data[@]0:max_lines}"
elif [[ $cmdf = hostname ]]; then
	#!/usr/bin/env bash
	#
	# hostname in pure bash.
	
	: '\h'
	printf '%s\n' "${_@P}"
elif [[ $cmdf = locale ]]; then
	#!/usr/bin/env bash
	#
	# locale in pure bash.
	
	locale_vars=(
	    LANG
	    LC_CTYPE
	    LC_NUMERIC
	    LC_TIME
	    LC_COLLATE
	    LC_MONETARY
	    LC_MESSAGES
	    LC_PAPER
	    LC_NAME
	    LC_ADDRESS
	    LC_TELEPHONE
	    LC_MEASUREMENT
	    LC_IDENTIFICATION
	)
	
	
	for var in "${locale_vars[@]}"; do
	    printf '%s=\"%s\"\n' "$var" "${!var:-$LANG}"
	done
	printf '%s=%s\n' "LC_ALL" "$LC_ALL"
elif [[ $cmdf = logname ]]; then
	#!/usr/bin/env bash
	#
	# logname in pure bash.
	
	: '\u'
	printf '%s\n' "${_@P}"
elif [[ $cmdf = ls ]]; then
	#!/usr/bin/bash
	#found this randomly and it kinda works
	printf '%s\n' *
elif [[ $cmdf = printenv ]]; then
	#!/usr/bin/env bash
	#
	# printenv in pure bash.
	
	[[ $1 ]] && {
	    printf '%s\n' "${!1}"
	    exit 0
	}
	
	mapfile -t envars < <(compgen -v)
	
	for var in "${envars[@]}"; do
	    printf '%s=%s\n' "$var" "${!var}"
	done
elif [[ $cmdf = printf ]]; then
	#!/usr/bin/env bash
	#
	# printf in pure bash.
	
	printf "$@"
elif [[ $cmdf = pwd ]]; then
	#!/usr/bin/env bash
	#
	# pwd in pure bash.
	
	printf '%s\n' "$PWD"
elif [[ $cmdf = realpath ]]; then
	#!/usr/bin/env bash
	#
	# realpath in pure bash.
	
	file="${1%/}"
	parent_dir="${file%/*}"
	
	[[ -f ${PWD}/${file##*/} ]] && {
	    printf '%s\n' "${PWD}/${file##*/}"
	    exit 0
	}
	
	cd "$parent_dir" &>/dev/null || exit 1 &&
	    printf '%s\n' "${PWD}/${file##*/}"
elif [[ $cmdf = seq ]]; then
	#!/usr/bin/env bash
	#
	# seq in pure bash.
	
	[[ -z $1 ]] && {
	    printf '%s\n' "seq: error: missing arguments." >&2
	    exit 1
	}
	
	[[ $2 ]] &&
	    first="$1"
	
	[[ $3 ]] &&
	    increment="$2"
	
	last="${*: -1}"
	
	for ((i=${first:=1};i<=last;i+=${increment:=1})); {
	    printf '%s\n' "$i"
	}
elif [[ $cmdf = sh ]]; then
	#!/usr/bin/env bash
	bash --posix $@
elif [[ $cmdf = sleep ]]; then
	#!/usr/bin/env bash
	if [ -z $1 ]; then
	  echo "sleep: syntax error"
	  exit
	fi
	read -d "" -rt $1
elif [[ $cmdf = tail ]]; then
	#!/usr/bin/env bash
	#
	# tail in pure bash.
	
	while getopts ":n:" opt; do
	    case $opt in
	        n) max_lines="$OPTARG" ;;
	
	        :)
	            printf '%s\n' "option -$OPTARG requires an argument." >&2
	            exit 1
	        ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	
	    shift "$((OPTIND - 1))"
	done
	
	[[ ! -f $1 ]] && {
	    printf '%s\n' "tail: ${1:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile -tn 0 file_data < "$1"
	
	[[ ${max_lines:=0} -gt "${#file_data[@]}" ]] &&
	    max_lines="${#file_data[@]}"
	
	printf '%s\n' "${file_data[@]: -$max_lines}"
elif [[ $cmdf = time ]]; then
	$@
	echo "$SECONDS"
elif [[ $cmdf = touch ]]; then
	#!/usr/bin/env bash
	#touch in pure bash
	if [ ! -f $1 ]; then
	 >$1
	fi
elif [[ $cmdf = true ]]; then
	#!/usr/bin/env bash
	#
	# true in pure bash.
	exit 0
elif [[ $cmdf = uname ]]; then
	#!/usr/bin/env bash
	if [ -z $1 ]; then
	 echo $OSTYPE
	elif [ $1 = -m ]; then
	 printf '%s\n' "${MACHTYPE%%-*}"
	elif [ $1 = --old ]; then
	 info="${MACHTYPE}"
	 os="${info%-*}"
	 os="${os##*-}"
	 echo $os
	elif [ $1 = --type ]; then
	 echo $MACHTYPE
	elif [ $1 = -a ]; then
	 printf '%s\n' "$(<"/proc/version")"
	else 
	 echo "flags: -m --old --type -a"
	fi
elif [[ $cmdf = uptime ]]; then
	#!/usr/bin/env bash
	#
	# uptime in pure bash.
	
	: "$(</proc/uptime)"
	seconds_up=${_%%.*}
	if [[ "$#" == 0 ]]; then
	    printf ' %(%H:%M:%S)T up '
	    if [[ $((minutes_up)) -ge 1440 ]]; then
	        printf '%d days, ' $((minutes_up/1440))
	    fi
	    if [[ $((minutes_up)) -ge 60 ]]; then
	        printf '%2d:%02d' $((minutes_up%1440/60)) $((minutes_up%60))
	    else
	        printf '%d min' $minutes_up
	    fi 
	else
	    getopts sp options
	    case $options in
	        s) current_timestamp=$(printf '%(%s)T')
	           printf '%(%Y-%m-%d %H:%M:%S)T\n' $((current_timestamp-seconds_up));;
	        p) minutes_up=$((seconds_up/60))
	           printf 'up '
	           if [[ $((minutes_up)) -ge 60 ]]; then
	               printf '%d hours, ' $((minutes_up/60))
	           fi
	           printf '%d minutes\n' $((minutes_up%60));;
	        ?) echo "$0: invalid option -- '$options'
	Usage: $0 [-ps]">&2;;
	    esac
	fi
elif [[ $cmdf = wc ]]; then
	#!/usr/bin/env bash
	#
	# wc in pure bash.
	
	while getopts "lcw" opt; do
	    case $opt in
	        l) lines=1 ;;
	        c) bytes=1 ;;
	        w) words=1 ;;
	
	        ?)
	            printf '%s\n' "error: -$OPTARG not a valid option." >&2
	            exit 1
	        ;;
	    esac
	done
	
	[[ -t 0 && -f ${*: -1} ]] &&
	    file=${*: -1}
	
	[[ -t 0 && ! -f $file ]] && {
	    printf '%s\n' "wc: ${file:-null}: No such file or directory." >&2
	    exit 1
	}
	
	mapfile file_data < "${file:-/dev/stdin}"
	
	for line in "${file_data[@]}"; do
	    read -ra line_split <<< "$line"
	    ((splits+=${#line_split[@]}, chars+=${#line}))
	done
	
	[[ -z $lines && -z $bytes && -z $words ]] &&
	    ((lines=1, bytes=1, words=1))
	
	[[ $lines ]] && printf '%s ' "${#file_data[@]}"
	[[ $words ]] && printf '%s ' "$splits"
	[[ $bytes ]] && printf '%s ' "$chars"
	
	printf '%s\n' "$file"
elif [[ $cmdf = whoami ]]; then
	#!/usr/bin/env bash
	#
	# logname in pure bash.
	
	: '\u'
	printf '%s\n' "${_@P}"
elif [[ $cmdf = yes ]]; then
	#!/usr/bin/env bash
	#
	# yes in pure bash.
	
	if [[ "$1" ]]; then
	    for ((;;)); {
	        printf '%s\n' "$1"
	    }
	else
	    for ((;;)); {
	        printf y\\n
	    }
	fi
else
 echo arch basename cat clear cp date dirname echo env exec expand expr false head hostname locale logname ls printenv printf pwd realpath seq sh sleep tail time touch true uname uptime wc whoami yes
fi
